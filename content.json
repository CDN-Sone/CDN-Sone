{"posts":[{"title":"ThreadLocal源码解析","text":"最近在整理ThreadLocal，打算把这方面的内容好好理一理。 概述 ThreadLocal 是一个线程的本地变量，这个变量是线程独有，且不能与其他线程共享的。 我们都知道线程是处理器调度的基本单位，而进程是资源调度的基本单位。在高并发情况下如果线程频繁去访问内存资源极容易造成线程冲突，而且有些线程工作需要线程去维护一个临时变量，ThreadLocal就是每个线程都有一个资源副本，是不需要加锁的。 可以这样去理解： 锁是通过时间换空间的做法。 ThreadLocal是通过空间换时间的做法 源码解析 set方法 123456789101112131415/** * 若map为空，则创建ThreadLocalMap */public void set(T value) { Thread t = Thread.currentThread(); //获取当前前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { //调用ThreadLocalMap的set方法 map.set(this, value); } else { createMap(t, value); }} 我们可以看到ThreadLocalMap对象只有在第一次调用时才会通过createMap方法初始化。 我们先看一下createMap方法，ThreadLocalMap的set方法稍后再看。createMap是ThreadLocal里的方法,他需要传入当前线程和新值 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} 我们可以看到，这里new出来的ThreadLocalMap赋值给Thread对象里的threadLocals变量，从这里可以看出ThreadLocalMap是当前线程Thread的一个全局变量。同时它在初始化ThreadLocalMap时还传入了一个this指针，这个指针就是ThreadLocal对象。 接下来我们看看ThreadLocalMap的初始化函数 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) { //INITIAL_CAPACITY = 16 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);} 我们可以看到这里ThreadLocalMap初始化的基本流程： 初始化ThreadLocalMap里的Entry类型的数组变量table 计算firstKey的hashCode，用坐数组下标 这里我们注意firstKey时刻指代的是ThreadLocal对象,计算下标时是通过hashCode和的(INITIAL_CAPACITY - 1)与运算 给table[i]赋值 初始化size 设置table阈值 我们再来看看ThreadLocalMap的set(this,value)方法 123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) { // 这里的tab是table的一个弱引用 Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); /** * 这里判读e!=null就很灵性了，说明循环退出条件是一直往数组下一个index查找，直到下一个index对应的元素为null；（这个不就是我们的开放地址法） * * 这里遍历的逻辑是，先通过hash找到数组下标，然后寻找相等的ThreadLocal对象，找不到就往下一个index找。 */ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); //找到了相同key的ThreadLocal对象，然后更新value值，退出； if (k == key) { e.value = value; return; } //找到了数组中的一个元素Entry，但是key=null，说明虚引用是可被GC回收的状态，赋值完后，整理内存后退出； if (k == null) { replaceStaleEntry(key, value, i); return; } } //此时tab[i]值为null 可以赋值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) /** 对table数组和元素进行整理操作，超过阈值rehash*/ rehash();} 总结一下上述的关系，当我梦创建一个ThreadLocal对象并调用set方法时，这个对象才会去查找当前线程是否包含ThreadLocalMap对象（变量threadLocals,可以理解为Threadlocal对象到value到映射）,没有则创建。在ThreadLocalMap对象里包含了一个Entry[]数组，在数组上面查找返回值。（底层是利用数组构建hash表，解决冲突使用开放地址法。 nextIndex和prevIndex 接下来，我们再细看一下其中涉及到的方法，首先是移动地址i的方法 1234567private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0);}private static int prevIndex(int i, int len) { return ((i - 1 &gt;= 0) ? i - 1 : len - 1);} 分析代码可得，当i超过len时，会访问下标0,也就是说这是循环查找（开饭地址法嘛）。 replaceStaleEntry 当这个已存在的Entry元素key==null的时候，逻辑上就走到——replaceStaleEntry(key, value, i)，该方法是用来替换“陈旧的”Entry的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; /** * 从过期key的位置用preIndex向前查找 * 并标记在staleSlot前连续的Entry中第一个过期的key为stolToExpunge */ for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 从过期key的位置用newIndex向后查找 */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { /** * 从staleSlot后的位置找到一个与key值相同的Entry * 根据开放地址法可知，我们应该清除掉后面的(key,.),把新值到前面的key中 */ e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // 若相等，说明在staleSlot前面找不到失效的key,直接清理i处的slot，退出即可 if (slotToExpunge == staleSlot) slotToExpunge = i; //这里优先清理掉是staleSlot前的过期key cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } /** * 从staleSlot后的位置找到一个与key过期的Entry 且在staleSlot前没有找到一个过期key,才会赋值slotToExpunge 为 i * 到这我们可以发现若要slotToExpunge = i,必须有slotToExpunge == staleSlot * 从这里可以看出优先清理staleSlot位置前过期的key */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; } // 上面循环结束说明后面没有相同的key值需要清理，可直接在staleSlot上赋值 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) //此时说明找到了一个待清除掉slotToExpunge位置，且优先清理靠前的位置。 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);} 在分析上述代码后，我们可知replaceStaleEntry总共做了两件事情： 在过期的key的位置附上新值，（但是在赋值前一定会向后检测是否存在相同key的值，若有一定要清楚掉） 去找在staleSlot里连续的Entry里第一个过期的Endtry的位置，并把它传入expungeStaleEntry（注意这个位置肯定是我们填完新（key,value）后的位置）。 这里给出一张replaceStaleEntry等图示，注意理解连续的Entry的概念 这里有个问题，为啥一定要找连续的Entry里第一个过期的Endtry的位置，我们可以看看expungeStaleEntry方法和cleanSomeSlots方法 expungeStaleEntry 1234567891011121314151617181920212223242526272829303132333435363738private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; /** 清除staleSlot槽位对应的对象引用 */ tab[staleSlot].value = null; tab[staleSlot] = null; size--; /** 数组中元素总数减1 */ Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); /** 如果key==null，则清除掉对应槽位的元素，并且size减1 */ if (k == null) { e.value = null; tab[i] = null; size--; } else { /** * 这里主要的作用是由于采用了开放地址法，所以删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，可以简单理解 * 就是让后面的元素往前面移动。 */ int h = k.threadLocalHashCode &amp; (len - 1); // 应该坐：h 但是我坐在了：i if (h != i) { // 表示k现在所在的位置i并不是它应该在的位置h上。而是由于开放地址法，放到了别的位置上 tab[i] = null; //找到h所在的位置，若tab[h] == null,说明h在前面被清除的位置，直接存值 while (tab[h] != null) { // 说明hash是有冲突的，那么往后找空的位置 h = nextIndex(h, len); } tab[h] = e; } } } //此时在staleSlot和i之间已经没有过期的key,i后面的都是null return i;} 现在我们可以理解为什么要去找最连续entry里第一个过期key了： 根据开放地址法，当我们扫到null时会停止扫描，而当我们扫到过期key时会清理掉该key，为了防止后面的key扫描不到，因此我们应该整理从连续entry里第一个过期key开始整理，遇到一个过期key便删除，同时重新计算后面的每个元素并排序。 cleanSomeSlots 1234567891011121314151617// 初始状态n=lengthprivate boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) { //遇到过期键则删除 n = len; removed = true; i = expungeStaleEntry(i); // 从位置i开始清除Stale元素，并在这个过程中&quot;整理&quot;元素到趋近正确的位置，直到遍历到null的Slot } } while ( (n &gt;&gt;&gt;= 1) != 0); /** n&gt;&gt;&gt;=1相当于n=n/2*/ // i 连续移动log2(len)次，若再每遇到过期键则退出 return removed;} 现在知道为什么这个方法称为cleanSomeSlots,该方法只能保证大部分的陈旧键被删除 可以理解为是对于提升插入速度和table数组内“陈旧”Entry整理耗时的一种平衡处理方案 rehash 12345678private void rehash() { expungeStaleEntries(); /** 清除表中的所有陈旧条目 */ // Use lower threshold for doubling to avoid hysteresis（使用较低的加倍阈值以避免滞后） if (size &gt;= threshold - threshold / 4) { resize(); /** 扩容操作 */ }} 超过table的3/4则扩容。 expungeStaleEntries 遍历table数组里的Entry，调用expungeStaleEntry方法，这里就不粘源码了。 resize 1234567891011121314151617181920212223242526272829303132private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; /** 将原数组大小扩容2倍 */ int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; // Help the GC } else { /**计算旧的Entry在新的table数组中的位置h */ int h = k.threadLocalHashCode &amp; (newLen - 1); /** * 如果位置h已经被别的Entry占据了，那么就向后查找空位，直到找到为止 */ while (newTab[h] != null) { h = nextIndex(h, newLen); } newTab[h] = e; count++; } } } /** 因为使用了新的数组，所以设置一下新的table数组的阈值 */ setThreshold(newLen); size = count; table = newTab;} 简单来说就是创建新数组，遍历旧数组的每一个值，计算新的hashCode，赋值。 内存溢出 通过上面的分析，我们知道 expungeStaleEntry() 方法是帮助垃圾回收的。 get 和set 方法都可能触发清理方法 expungeStaleEntry() 正常情况下，不会存在溢出，但是 如果我们没有调用get和set的时候就会可能面临着内存溢出。养成好习惯不再使用的时候调用remove()，加快垃圾回收，避免内存溢出。退一步说，就算我们没有调用get和set和remove方法，线程结束的时候，也就没有强引用再指向ThreadLocal中的ThreadLocalMap了，这样ThreadLocalMap和里面的元素也会被回收掉。但是有一种危险是，如果线程是线程池的，在线程执行完代码的时候并没有结束，只是归还给线程池，这个时候ThreadLocalMap和里面的元素是不会回收掉的。 最近把java并发编程的知识重新整理了一下，有一部分文档写在飞书上了。内容和图片来自于互联网，有侵删。 这是以前做的一些笔记：Java并发编程","link":"/2024/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"YHJ23","text":"今天读一篇发在FOCS上的论文 Attribute-Based Encryption for Circuits of Unbounded Depth from Lattices 文章很长，先从方法论下手，浅读一下方法，细节部分日后再补充。 研究背景 目前主流的基于格的ABE芳芳如GVW13,BGG+14等，所能够容纳的电路深度都是有限的，同时它们的组件（主公钥，主私钥，和密文）在最大电路中具有多项式大小深度。（这句话读起来有些费解，我的理解是，例如深度为2，则有22=42^2=422=4个辅助电路加密的公钥或者说对应的密文，而计算密钥时计算深度也会达到2）。为了消除基于格的ABE对电路深度的依赖，作者提出了一种新的方案 研究成果 作者提出构造一个1-key ABE所用到的密码学原语有 laconic function evaluation (LFE) 1-key functional encryption (FE) reusable garbling schemes. 作者构造了一系列上述原语的方案，同时还基于evasive circular LWE assumption（一种加强的evasive LWE assumption）实现了一个比较成熟的ABE方案。 预备知识 再了解整个方案之前，我们先看一下所用到的组件 Circular Evasive LWE 我们先从evasive LWE开始，如下为evasive LWE假设的内容，为了方便理解后面的Circular Evasive LWE,B,A‾′B,\\overline{A}^{\\prime}B,A′采用了相同的分布，两个变量在这里是一样的。 if (1): B,A‾′,P,r⊤B⏟,r⊤⏟A‾′,r⊤P⏟\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{B}}, \\underbrace{\\mathbf{r}^{\\top}} \\overline{\\mathbf{A}}^{\\prime}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{P}}B,A′,P,r⊤B​,r⊤​A′,r⊤P​, aux ≈\\approx≈ (2): B,A‾′,P,$,$,$\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\$B,A′,P,$,$,$, aux, then (3): B,A‾′,P,r⊤B,r⊤A‾′,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\mathbf{r}^{\\top} \\mathbf{B}, \\mathbf{r}^{\\top} \\overline{\\mathbf{A}}^{\\prime}, \\quad \\mathbf{K}B,A′,P,r⊤B,r⊤A′,K, aux ≈\\approx≈ (4): B,A‾′,P,$,$,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\mathbf{K}B,A′,P,$,$,K, aux. 其中B←$Zqn×m\\mathbf{B}\\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_q^{n \\times m}B←$Zqn×m​, m=Θ(nlog⁡p)m=\\Theta(n \\log p)m=Θ(nlogp), K←$B−1(P)\\mathbf{K} \\stackrel{\\$}{\\leftarrow} \\mathbf{B}^{-1}(\\mathbf{P})K←$B−1(P), K\\mathbf{K}K是一个低范数矩阵满足BK=P\\mathbf{B K}=\\mathbf{P}BK=P。我们可以这么去理解这个假设，只要不给敌手获悉BK=P\\mathbf{B K}=\\mathbf{P}BK=P，给定X\\mathbf{X}X,r⊤B+e\\mathbf{r}^{\\top} \\mathbf{B}+er⊤B+e,r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e,不论X\\mathbf{X}X为何种分布，r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e均为伪随机性的。 circular evasive LWE假设如下， if (1), Afhe ,S,Acirc ,s⊤(Acirc −S⊗G)≈(2),$,$,Acirc ,$, then (3), Afhe ,S,Acirr ,s⊤(Acirc −S⊗G)≈ (4), $,$,Acirc , \\begin{aligned} &amp;\\text { if (1), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {circ }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx(2), \\$, \\$, \\mathbf{A}_{\\text {circ }}, \\quad \\$ \\text {, } \\\\ &amp; \\text { then (3), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {cirr }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx \\text { (4), } \\$, \\$, \\mathbf{A}_{\\text {circ }} \\text {, } \\\\ \\end{aligned} ​ if (1), Afhe ​,S,Acirc ​,s⊤(Acirc ​−S⊗G)≈(2),$,$,Acirc ​,$, then (3), Afhe ​,S,Acirr ​,s⊤(Acirc ​−S⊗G)≈ (4), $,$,Acirc ​, ​ 这里暂时认为这个假设是对的，不看这方面的证明。 模数法缩小噪声 我们有如下方法缩减噪声，令MMM为qqq的因子，CCC为一个低深度的电路，如下等式成立： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌋=(s⊤AC, small −C(x)s⊤Gsmall +esmall ⊤) mod qM\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rfloor \\\\ = &amp; \\left(\\mathbf{s}^{\\top} \\mathbf{A}_{C, \\text { small }}-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}+\\mathbf{e}_{\\text {small }}^{\\top}\\right) \\bmod \\frac{q}{M} \\end{aligned}=​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎥⎥⎥​(s⊤AC, small ​−C(x)s⊤Gsmall ​+esmall ⊤​)modMq​​ 经推理可得： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM]=(⌊(s⊤AC+elarge ⊤) mod qM⌉−C(x)s⊤Gsmall ) mod qM=Φ(⌊s⊤AC mod qM⌉−C(x)s⊤Gsmall ) mod qM.\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right] \\\\ = &amp; \\left(\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top} \\mathbf{A}_C+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} \\\\ \\stackrel{\\Phi}{=} &amp; \\left(\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} .\\end{aligned}==Φ​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎤​⎝⎛​⎣⎢⎢⎢​M(s⊤AC​+elarge ⊤​)modq​⎥⎥⎥⎤​−C(x)s⊤Gsmall ​⎠⎞​modMq​(⌊Ms⊤AC​modq​⌉−C(x)s⊤Gsmall ​)modMq​.​ 为了让第一个等式成立，M为2的指数次放，这样可以使得M/GM/GM/G为整数,让M/GM/GM/G能被规约为GsmallG_{small}Gsmall​。 注意第二个等式是概率成立的，即，当elargee_{large}elarge​没有足够大时，可以使得四舍五入后的值相同。通过规约后再乘以M,可以舍得原式变回模M. M⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌉=(M⌊s⊤AC mod qM⌉−C(x)s⊤⋅MGsmall ) mod q\\begin{aligned} &amp; M\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil \\\\ = &amp; \\left(M\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\cdot M \\mathbf{G}_{\\text {small }}\\right) \\bmod q\\end{aligned}=​M⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎥⎥⎥⎤​(M⌊Ms⊤AC​modq​⌉−C(x)s⊤⋅MGsmall ​)modq​ 利用四舍五入可以使得恢复该数恢复到模q。但是这里有个坑，MGsmallMG_{small}MGsmall​只包含较大的2的幂次方，所以还需要设计一种可以恢复G的方法。（这里细节比较多，暂时不讲）解决的大致思路就是把G分为两部分，一部分是可以通过⌊XM⌉M\\left \\lfloor \\frac{X}{M} \\right \\rceil M⌊MX​⌉M复原的部分，和不能通过其复原的部分。 最后我们可以得到函数RemoveNoise(u⊤u^{\\top}u⊤),计算公式如下： vL⊤←u⊤G−1(MGL),vR⊤←u⊤G−1(GR),w⊤←(⌊vL⊤ mod qM⌉,M⌊vR⊤ mod qM⌉)Q,\\begin{array}{l} \\mathbf{v}_{\\mathrm{L}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(M \\mathbf{G}_{\\mathrm{L}}\\right), \\quad \\mathbf{v}_{\\mathrm{R}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{G}_{\\mathrm{R}}\\right), \\\\ \\mathbf{w}^{\\top} \\leftarrow\\left(\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{L}}^{\\top} \\bmod q}{M}\\right\\rceil, M\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{R}}^{\\top} \\bmod q}{M}\\right\\rceil\\right) \\mathbf{Q}, \\end{array} vL⊤​←u⊤G−1(MGL​),vR⊤​←u⊤G−1(GR​),w⊤←(⌊MvL⊤​modq​⌉,M⌊MvR⊤​modq​⌉)Q,​ 这里的Q是什么暂且不深入讲解。 我们定义一个函数RndPad满足： RndPadA(s)=RemoveNoise(s⊤A+e)=s⊤ARndPad_{A}(s)=RemoveNoise(s^{\\top}A+e)=s^{\\top}ARndPadA​(s)=RemoveNoise(s⊤A+e)=s⊤A bootstrapping 接下来是文章中最重要的阶段，我们定义一个 S=(A‾fhe r⊤A‾fhe +efhe ⊤)(R1,…,R(n+1)⌈log⁡2q⌉)−bits⁡(s)⊗G∈Zq(n+1)×m(n+1)⌈log⁡2q⌉ \\begin{array}{l} \\mathbf{S}=\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}}\\left(\\mathbf{R}_{1}, \\ldots, \\mathbf{R}_{(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}\\right) \\\\ -\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G} \\in \\mathbb{Z}_{q}^{(n+1) \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil} \\end{array} S=(r⊤Afhe ​+efhe ⊤​Afhe ​​)(R1​,…,R(n+1)⌈log2​q⌉​)−bits(s)⊗G∈Zq(n+1)×m(n+1)⌈log2​q⌉​​ A‾fhe ,R\\overline{\\mathbf{A}}_{\\text {fhe }},RAfhe ​,R均可以理解为随机矩阵。 我们定义循环编码为： s⊤(Acirc −(1,bit(S))⊗G)+ecirc \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1,\\text{bit}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{circ}} s⊤(Acirc ​−(1,bit(S))⊗G)+ecirc​ 则对于该循环编码，存在 EvalRndPad(Acirc ,A)=HARdPad EvalRndPadS(Acirc ,A,S)=HA,SRdPad \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}) = \\mathbf{H}_{\\mathbf{A}}^{\\text {RdPad }}\\\\ \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} EvalRndPad(Acirc ​,A)=HARdPad ​EvalRndPadS(Acirc ​,A,S)=HA,SRdPad ​ 满足： s⊤(Acirc −(1,bits⁡(S))⊗G)HA,SRdPad =s⊤Acirc HARndPad −RndPad⁡A(s)+efhe ⊤RRndPad A\\begin{aligned} &amp; \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} \\\\ = &amp; \\mathbf{s}^{\\top} \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}}^{\\text {RndPad }}-\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})+\\mathbf{e}_{\\text {fhe }}^{\\top} \\mathbf{R}_{\\text {RndPad }_{\\mathbf{A}}} \\end{aligned} =​s⊤(Acirc ​−(1,bits(S))⊗G)HA,SRdPad ​s⊤Acirc ​HARndPad ​−RndPadA​(s)+efhe ⊤​RRndPad A​​​ 实际上，通过，观察我们可以发现这里将(1,bits⁡(S))(1, \\operatorname{bits}(\\mathbf{S}))(1,bits(S))转化成RndPad⁡A(s)\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})RndPadA​(s),实际上是做了一个RemoveNoise的运算电路， Unbounded Homomorphic Evaluation 这部分运算同EvalC,和EvalCX一样分别分为两部分UEvalC和UEvalX（详见BGG+14）,我们可以这样直观的理解： EvalC/UEvalC: 发声于密钥生成阶段，电路C可以是任意的，属于一种明文态的同态计算。 EvalCX/UEvalCX: 发声于解密阶段，若想要正确解密，电路C必须满足C(x)=1C(x)=1C(x)=1，属于一种密文态的同态计算。 我们来看在论文中的描述： UEvalC UEvalC(Aattr ,Acirc ,C)\\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)UEvalC(Aattr ​,Acirc ​,C) takes as input Aattr ∈Zq(n+1)×(L+1)m,Acirc ∈Zq(n+1)×(LS+1)m\\mathbf{A}_{\\text {attr }} \\in \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\quad \\mathbf{A}_{\\text {circ }} \\in \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m} Aattr ​∈Zq(n+1)×(L+1)m​,Acirc ​∈Zq(n+1)×(LS​+1)m​ and a circuit C:{0,1}L→{0,1}1×L′C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}^{1 \\times L^{\\prime}}C:{0,1}L→{0,1}1×L′ of arbitrary size and depth, where LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^{2}\\left\\lceil\\log _{2} q\\right\\rceil^{2}LS​=m(n+1)2⌈log2​q⌉2. 这里给出了UEvalC的基本算法，注意一下不论是Aattr\\mathbf{A}_{\\text {attr}}Aattr​还是Acirc\\mathbf{A}_{\\text {circ}}Acirc​都是用于构造电路的算法的。先令Aattr=(A0,A1,…,AL)\\mathbf{A}_{\\text {attr}}=\\left (\\mathbf{A}_{0},\\mathbf{A}_{1},\\dots,\\mathbf{A}_{L} \\right )Aattr​=(A0​,A1​,…,AL​), 我们可以先用Acirc\\mathbf{A}_{\\text {circ}}Acirc​做传统的电路运算 HCi′←EvalC⁡((A0,Ai′,Ai′′), gate Ci as one-gate circuit ),Ai′←(A0,Ai′,Ai′′)HCi′\\begin{array}{l} \\mathbf{H}_{C_{i}}^{\\prime} \\leftarrow \\operatorname{EvalC}\\binom{\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right),}{\\text { gate } C_{i} \\text { as one-gate circuit }}, \\\\ \\mathbf{A}_{i}^{\\prime} \\leftarrow\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right) \\mathbf{H}_{C_{i}}^{\\prime} \\\\ \\end{array} HCi​′​←EvalC( gate Ci​ as one-gate circuit (A0​,Ai′​,Ai′′​),​),Ai′​←(A0​,Ai′​,Ai′′​)HCi​′​​ 最后根据上面的运算结果，即： HAi′RndPad←EvalRndPad(Acirc ,Ai′),Ai←Acirc HAi′RndPad\\begin{array}{l} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}} \\leftarrow \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{i}^{\\prime}), \\\\ \\mathbf{A}_{i} \\leftarrow \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}}\\\\ \\end{array} HAi′​RndPad​←EvalRndPad(Acirc ​,Ai′​),Ai​←Acirc ​HAi′​RndPad​​ 这里摘自于原论文，个人感觉符号使用有点混乱了 UEvalCX 这里就是同理了，不再过多赘述，如果在密态情况下EvalCX,计算出来的是形如： AwithLargeNoise′=s⊤(AC−C(x)⊗G)+elarge \\mathbf{A}_{\\text{withLargeNoise}}^{\\prime}=\\mathbf{s}^{\\top}\\left(\\mathbf{A}_{C}-C(x) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{large}} AwithLargeNoise′​=s⊤(AC​−C(x)⊗G)+elarge​ 但是在计算 EvalRndPadS(Acirc ,AwithLargeNoise′,S)=HA,SRdPad \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{\\text{withLargeNoise}}^{\\prime},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }}EvalRndPadS(Acirc ​,AwithLargeNoise′​,S)=HA,SRdPad ​ 中，由于用了循环编码EvalRndPadS可以计算出与EvalRndPad相同的值。 方案 先来看看方案的原算法吧，为了更好的理解以下摘自于原文，我会附上相关的自己的理解 Setup (1L)\\left(1^L\\right)(1L) defines appropriate n,m,q,σ,σ′,σ−1n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1}n,m,q,σ,σ′,σ−1​, σpost \\sigma_{\\text {post }}σpost ​ as described at the end of Section 3, and sets LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^2\\left\\lceil\\log _2 q\\right\\rceil^2LS​=m(n+1)2⌈log2​q⌉2. The algorithm samples: Aattr ←Zq(n+1)×(L+1)m,Acirc ←Zq(n+1)×(LS+1)m,(B,τ)←TrapGen⁡(1n,1m,q),z←Zqn\\begin{aligned} \\mathbf{A}_{\\text {attr }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\\\ \\mathbf{A}_{\\text {circ }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m}, \\\\ (\\mathbf{B}, \\tau) &amp; \\leftarrow \\operatorname{TrapGen}\\left(1^{n}, 1^{m}, q\\right), \\quad \\mathbf{z} \\leftarrow \\mathbb{Z}_{q}^{n} \\end{aligned} Aattr ​Acirc ​(B,τ)​←Zq(n+1)×(L+1)m​,←Zq(n+1)×(LS​+1)m​,←TrapGen(1n,1m,q),z←Zqn​​ It outputs mpk=(n,m,q,σ,σ′,σ−1,σpost ,Aatt ,Acirc ,B,z),msk=(mpkτ)\\mathrm{mpk}=\\binom{n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1},}{\\sigma_{\\text {post }}, \\mathbf{A}_{\\text {att }}, \\mathbf{A}_{\\text {circ }}, \\mathbf{B}, \\mathbf{z}}, \\mathrm{msk}=\\binom{\\mathrm{mpk}}{\\tau}mpk=(σpost ​,Aatt ​,Acirc ​,B,zn,m,q,σ,σ′,σ−1​,​),msk=(τmpk​). 启动阶段，生成陷门和循环电路参数以及属性参数。 KeyGen(msk,C)(msk, C)(msk,C) takes msk,C:{0,1}L→{0,1}msk, C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}msk,C:{0,1}L→{0,1} as input. It computes AC←UEvalC(Aattr ,Acirc ,C)\\mathbf{A}_{C} \\leftarrow \\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)AC​←UEvalC(Aattr ​,Acirc ​,C) and samples z′←Zqn+1\\mathbf{z}^{\\prime} \\leftarrow \\mathbb{Z}_{q}^{n+1}z′←Zqn+1​. The algorithm generates a trapdoor k←$SimplD(B,τ,A‾CG−1(z′)+z,σ−1),k \\stackrel{\\$}{\\leftarrow} \\text{SimplD}(\\mathbf{B},\\tau,\\overline{\\mathbf{A}}_{C}G^{-1}(z')+z,\\sigma_{-1}), k←$SimplD(B,τ,AC​G−1(z′)+z,σ−1​), whereA‾C∈Zqn×m\\overline{\\mathbf{A}}_{C} \\in \\mathbb{Z}_{q}^{n \\times m}AC​∈Zqn×m​ is the the first nnn rows of AC\\mathbf{A}_{C}AC​. The algorithm outputs skC=(z′,k)\\mathrm{sk}_{C}=\\left(\\mathbf{z}^{\\prime}, \\mathbf{k}\\right)skC​=(z′,k). 这里做了UEvalC计算，并且运用了陷门，生成密钥，若想要解密，必须生成相同的值 可以理解为用陷门对ACA_{C}AC​进行了一次签名，只不过这种签名是密态的。 Enc (mpk,x,μ)(\\mathrm{mpk}, \\mathbf{x}, \\mu)(mpk,x,μ) takes mpk,x∈{0,1}L,μ∈{0,1}mpk, \\mathbf{x} \\in\\{0,1\\}^{L}, \\mu \\in\\{0,1\\}mpk,x∈{0,1}L,μ∈{0,1} as input. It samples r←DZ,σ,≤σλn\\mathbf{r} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{n}r←DZ,σ,≤σλ​n​ and sets s←(r⊤,−1)⊤\\mathbf{s} \\leftarrow\\left(\\mathbf{r}^{\\top},-1\\right)^{\\top}s←(r⊤,−1)⊤. The algorithm creates a circular encryption by A‾fhe ←&amp;Zqn×m,efhe ←&amp;DZ,σ,≤σλmR←${0,1}m×m(n+1)⌈log⁡2q⌉,Afhe ←(A‾fhe r⊤A‾fhe +efhe ⊤), S←Afhe R−bits⁡(s)⊗G,\\begin{array}{l} \\overline{\\mathbf{A}}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_{q}^{n \\times m}, \\quad \\mathbf{e}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{m}\\\\ \\mathbf{R} \\stackrel{\\$}{\\leftarrow}\\{0,1\\}^{m \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}, \\\\ \\mathbf{A}_{\\text {fhe }} \\leftarrow\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}} \\text {, } \\\\ \\mathbf{S} \\leftarrow \\mathbf{A}_{\\text {fhe }} \\mathbf{R}-\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G}, \\\\ \\end{array} Afhe ​←&amp;Zqn×m​,efhe ​←&amp;DZ,σ,≤σλ​m​R←${0,1}m×m(n+1)⌈log2​q⌉,Afhe ​←(r⊤Afhe ​+efhe ⊤​Afhe ​​), S←Afhe ​R−bits(s)⊗G,​ than encoding by eattr ←DZ,σ′,≤σ′λ(L+1)m,ecirc ←DZ,σ′,≤σ′λ(Ls+1)m,cattr ⊤←s⊤(Aattr −(1,x⊤)⊗G)+eattr ⊤,ccirc ⊤←s⊤(Acirc −(1,bits⁡(S))⊗G)+ecirc ⊤.\\begin{array}{l} \\mathbf{e}_{\\text {attr }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L+1) m}, \\quad \\mathbf{e}_{\\text {circ }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L \\mathbf{s}+1)m}, \\\\ \\mathbf{c}_{\\text {attr }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {attr }}-\\left(1, \\mathbf{x}^{\\top}\\right) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {attr }}^{\\top}, \\\\ \\mathbf{c}_{\\text {circ }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {circ }}^{\\top} . \\end{array} eattr ​←DZ,σ′,≤σ′λ​(L+1)m​,ecirc ​←DZ,σ′,≤σ′λ​(Ls+1)m​,cattr ⊤​←s⊤(Aattr ​−(1,x⊤)⊗G)+eattr ⊤​,ccirc ⊤​←s⊤(Acirc ​−(1,bits(S))⊗G)+ecirc ⊤​.​ It also generates the message encoding as eB←DZ,σpost ,≤σpost λm,emsg←DZ,σ′,≤σ′λcB⊤←r⊤B+eB⊤,cmsg←r⊤z+emsg+μ⋅⌊q/2⌉.\\begin{aligned} \\mathbf{e}_{\\mathrm{B}} &amp; \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma_{\\text {post }}, \\leq \\sigma_{\\text {post }} \\sqrt{\\lambda}}^{m}, \\quad e_{\\mathrm{msg}} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}} \\\\ \\mathbf{c}_{\\mathrm{B}}^{\\top} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{B}+\\mathbf{e}_{\\mathrm{B}}^{\\top}, \\\\ c_{\\mathrm{msg}} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{z}+e_{\\mathrm{msg}}+\\mu \\cdot\\lfloor q / 2\\rceil . \\end{aligned} eB​cB⊤​cmsg​​←DZ,σpost ​,≤σpost ​λ​m​,emsg​←DZ,σ′,≤σ′λ​​←r⊤B+eB⊤​,←r⊤z+emsg​+μ⋅⌊q/2⌉.​ The algorithm outputs ctx=(S,cattr,ccirc,cB,cmsg)ctx = (S, c_{attr}, c_{circ}, c_{B}, c_{msg})ctx=(S,cattr​,ccirc​,cB​,cmsg​). 与BGG+14不同的是生成了一个循环编码的密文。 Dec (A‾Ca‾C⊤)=AC←UEvalC⁡(Aatr ,Acirc ,C),cC,x⊤←UEvalCX⁡(Aattr ,cattr ⊤,Acirc ccirc ⊤,C,x,S),c′←cmsg+cC,x⊤G−1(z′)−(cB⊤k−a‾C⊤G−1(z′)).\\begin{aligned} \\binom{\\overline{\\mathbf{A}}_{C}}{\\underline{\\mathbf{a}}_{C}^{\\top}} &amp; =\\mathbf{A}_{C} \\leftarrow \\operatorname{UEvalC}\\left(\\mathbf{A}_{\\text {atr }}, \\mathbf{A}_{\\text {circ }}, C\\right), \\\\ \\mathbf{c}_{C, \\mathbf{x}}^{\\top} &amp; \\leftarrow \\operatorname{UEvalCX}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{c}_{\\text {attr }}^{\\top}, \\mathbf{A}_{\\text {circ }} \\mathbf{c}_{\\text {circ }}^{\\top}, C, \\mathbf{x}, \\mathbf{S}\\right), \\\\ c^{\\prime} &amp; \\leftarrow c_{\\mathrm{msg}}+\\mathbf{c}_{C, \\mathbf{x}}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)-\\left(\\mathbf{c}_{\\mathrm{B}}^{\\top} \\mathbf{k}-\\underline{\\mathbf{a}}_{C}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)\\right) . \\end{aligned} (a​C⊤​AC​​)cC,x⊤​c′​=AC​←UEvalC(Aatr ​,Acirc ​,C),←UEvalCX(Aattr ​,cattr ⊤​,Acirc ​ccirc ⊤​,C,x,S),←cmsg​+cC,x⊤​G−1(z′)−(cB⊤​k−a​C⊤​G−1(z′)).​ 最后我们对上文所有组件的分析，由与在密态下计算一个UEvalCX可以消除掉在属性电路CCC生成的噪声，因此最后的噪声与CCC无关，仅与removeNoise电路编码的生成的噪声有关，但是removeNoise是一个固定值，所以实现了一个电路无界的功能。","link":"/2024/05/28/YHJ23/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2024/05/27/hello-world/"}],"tags":[{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"源码解析","slug":"源码解析","link":"/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Lattice","slug":"Lattice","link":"/tags/Lattice/"},{"name":"ABE","slug":"ABE","link":"/tags/ABE/"},{"name":"new","slug":"new","link":"/tags/new/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"基于格的属性基加密","slug":"基于格的属性基加密","link":"/categories/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/"}],"pages":[]}
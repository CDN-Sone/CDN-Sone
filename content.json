{"posts":[{"title":"AQS与JUC","text":"在读这篇文章之前最好读读我前面的这篇文章：Java并发编程。 在这篇文章中我打算详细讲讲JUC包的几种锁，后面再补上AQS的源码分析。 首先我们明确一个区别，synchronized是由java JVM实现的，而Lock是由java JDK实现的。以下列了几个不同点 Synchronized是Java的内置关键字，Lock是一个java接口。 Synchronized无法判断获取锁的状态，Lock可以通过java.lang.Thread 中的holdsLock()方法判断是否获得某个对象的锁。 Synchronized会自动释放锁，Lock必须手动释放锁，否则可能产生死锁（手动使用lock和unlock方法）。 如果一个线程获得了锁，对于Synchronized来说其他需要使用这个资源的线程就只能等待下去，如果获得了锁的线程进入阻塞状态，其他线程依旧会等待，Lock锁就不一定会一直等待下去，可以通过tryLock尝试获取锁（线程是否等待）。 Synchronized是可重入锁，不可以中断，非公平的，Lock可重入锁，可以判断锁的状态，是否公平可以通过fair参数进行设置，相对而言比较灵活。 概述 首先我们从JUC包开始 我们首先了解JUC包下的几种锁 ReentrantLock重入锁 重入锁可以完全替代 synchronized 关键字。在java早期版本中，重入锁的性能远大于synchronized。但从JDK6.0开始，JDK在synchronized上做了大量的优化，使得两者的性能差距并不大。重入锁对逻辑控制的灵活性要远远好于synchronized。 使用方法比较简单： 123public ReentrantLock lock = new ReentrantLock();lock.lock();lock.unlock(); 这里注意，每个unlock()必须对应一个lock(),必须形成闭包。若unlock()数大于lock()数，则会抛出异常。 中断响应lockInterruptibly() 如果使用 synchronized ，要么获得锁，要么保持等待。而如果使用了重入锁，则提供了另一种可能，那就是线程可以被中断。也就是在等待锁的过程中，程序可以根据需要取消对锁的请求。即：如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。 而使用synchronized的锁要想停止线程，必须先获得锁，才能继续继续执行 123456789101112131415161718192021static class ReentrantLockThread implements Runnable { private ReentrantLock lock; public ReentrantLockThread(ReentrantLock lock) { this.lock = lock } @Override public void run() { try { lock.lockInterruptibly(); // 获得lock1的可中断锁 System.out.println(Thread.currentThread().getName() + &quot;，加锁成功！&quot;); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + &quot;，发生异常！&quot;); e.printStackTrace(); } finally { lock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;，lock解锁成功！&quot;); } }} 使用lockInterruptibly(),既是获取中断锁，若在此过程中发生异常，进程可以直接退出，这样的设计可以防止发生死锁。 tryLock(long time, TimeUnit unit) 1lock.tryLock(500, TimeUnit.MILLISECONDS) 该方法为在一定时间内试图获取锁，失败则返回。 tryLock()方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回true。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回false。 公平锁和非公平锁 在默认的情况下，锁的申请是非公平锁。我们知道sychronized在进入waitqueue时都会先经过几轮空循环,这个线程是有权利进行锁的争抢，所以sychronized锁是非公平的。 在默认情况下，ReentrantLock同样是非公平的，默认输入参数为false,当输入参数为true时，锁会转换成公平锁。公平锁默认会维护一个队列，这个我们以后再讲。 Condition重入锁 在使⽤内置锁synchronized时，通过调⽤Objec中定义的监视器⽅法，主要有wait(),wait(long timeout),notify()和notifyAll()⽅法，可以实现等待/通知模式。Codition接⼝中也定义了类似的监视器⽅法，与显示锁Lock配合使⽤也可以实现等待/ 通知模式。 常用方法方式如下 123Condition.await() //等待线程Condition.signal() //唤醒一个线程Condition.signalAll() //唤醒所有线程 Semaphore 信号量 synchronized和ReentrantLock机制都只允许获取锁（锁资源只有一个）的线程去访问资源，换而言之，只允许一个线程去访问资源。而Semaphore扩展了这种机制，可以指定多个线程同时访问某一个资源。 常用方法如下： 1234567891011void acquire(); //尝试获得⼀个准⼊的许可。若⽆法获得，则线程会等待，直到有线程释放⼀个 许可或者当前线程被中断。 void acquireUninterruptibly(); //具有acquire⼀样的功能，但是不响应中断 （Uninterruptibly）。 void tryAcquire(); //尝试获得⼀个许可，如果成功就⽴即返回true，失败则⽴即返回false。 void tryAcquire(long timeout, TimeUnit unit); //在指定时间内，尝试获得⼀个许可，如果成功 就返回true，失败则返回false。 void release(); 资源访问结束后，释放⼀个许可。 CountDownLatch倒计时器 CountDownLatch是⼀个多线程控制⼯具。⽤来控制线程的等待。设置需要countDown的数量num，然后每⼀个线程执⾏完毕后，调⽤countDown()⽅法，⽽主线程调⽤await()⽅ 法执⾏等待，直到num个⼦线程执⾏了countDown()⽅法 ，则主线程开始继续执⾏。 这个有点类似线程控制包里的join()方法。 ReadWriteLoc读写锁 ReadWriteLock由JDK5提供，它允许多个线程同时读。但是考虑到数据的完整性，写写操作和读写操作间依然是需要相互等待和持有锁的。 读 写 读 非阻塞 阻塞 读 阻塞 阻塞 如果在系统中，读操作的次数远远⼤于写操作，那么读写锁就可以发挥最⼤的效果， 提升系统的性能 CyclicBarrier循环栅栏 CyclicBarrier与CountDownLatch⾮常类似，它⽀持计数器的反复使⽤，CyclicBarrier可以理解为循环栅栏。CyclicBarrier可以接收⼀个参数作为Runnable barrierAction，每当计数器⼀次计数完成后——CyclicBarrier.await()时，系统会执⾏的动作。 LockSupport线程阻塞⼯具类 在之前的笔记中我们知道Thread.suspent,Thread.resume已经被废弃了，原因是如果使用不当，当先执行resume,后执行suspend将导致线程被永久阻塞。LockSupport类改善了这一情况，同时相比于使用监视器wait()或者Condition.await(),LockSupport不需要事先获取锁。 LockSupport包含两个方法，part,unpart。我们看看LockSupport是如何实现防止先调用unpart,后调用part导致线程被永远阻塞。 每⼀个线程都有⼀个许可，该许可默认为 不可⽤。如 果该许可是可⽤状态，那么park()⽅法会⽴即返回，消费这个许可，将该许可变更为不可⽤状态，流程代码可以继续执⾏。如果该许可是不可⽤状态，那么park()⽅法 将会阻塞；unpark⽅法，将指定线程的⼀个许可变为可⽤状态。 状态变化如表所示： 当前许可状态 调用后许可状态 park 可用 不可用 park 不可用 阻塞 unpark 可用 可用 unpark 不可用 可用 简而言之，经过unpart操作除阻塞状态变成非阻塞状态,其他所有状态都会变成可用状态，而当状态为不可用时是正常状态，若为可用，说明前面经过一次unpark,则调用park会将状态变回不可用状态。 同时注意park阻塞线程支持被中断，且中断后不会抛出InterruptedException异常。","link":"2024/06/04/AQS%E4%B8%8EJUC/"},{"title":"AQS源码解析(二)","text":"在读本文之前，希望你已经阅读了AQS与JUC","link":"2024/06/16/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/"},{"title":"ThreadLocal源码解析","text":"最近在整理ThreadLocal，打算把这方面的内容好好理一理。 概述 ThreadLocal 是一个线程的本地变量，这个变量是线程独有，且不能与其他线程共享的。 我们都知道线程是处理器调度的基本单位，而进程是资源调度的基本单位。在高并发情况下如果线程频繁去访问内存资源极容易造成线程冲突，而且有些线程工作需要线程去维护一个临时变量，ThreadLocal就是每个线程都有一个资源副本，是不需要加锁的。 可以这样去理解： 锁是通过时间换空间的做法。 ThreadLocal是通过空间换时间的做法 源码解析 set方法 123456789101112131415/** * 若map为空，则创建ThreadLocalMap */public void set(T value) { Thread t = Thread.currentThread(); //获取当前前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { //调用ThreadLocalMap的set方法 map.set(this, value); } else { createMap(t, value); }} 我们可以看到ThreadLocalMap对象只有在第一次调用时才会通过createMap方法初始化。 我们先看一下createMap方法，ThreadLocalMap的set方法稍后再看。createMap是ThreadLocal里的方法,他需要传入当前线程和新值 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} 我们可以看到，这里new出来的ThreadLocalMap赋值给Thread对象里的threadLocals变量，从这里可以看出ThreadLocalMap是当前线程Thread的一个全局变量。同时它在初始化ThreadLocalMap时还传入了一个this指针，这个指针就是ThreadLocal对象。 接下来我们看看ThreadLocalMap的初始化函数 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) { //INITIAL_CAPACITY = 16 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);} 我们可以看到这里ThreadLocalMap初始化的基本流程： 初始化ThreadLocalMap里的Entry类型的数组变量table 计算firstKey的hashCode，用坐数组下标 这里我们注意firstKey时刻指代的是ThreadLocal对象,计算下标时是通过hashCode和的(INITIAL_CAPACITY - 1)与运算 给table[i]赋值 初始化size 设置table阈值 我们再来看看ThreadLocalMap的set(this,value)方法 123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) { // 这里的tab是table的一个弱引用 Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); /** * 这里判读e!=null就很灵性了，说明循环退出条件是一直往数组下一个index查找，直到下一个index对应的元素为null；（这个不就是我们的开放地址法） * * 这里遍历的逻辑是，先通过hash找到数组下标，然后寻找相等的ThreadLocal对象，找不到就往下一个index找。 */ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); //找到了相同key的ThreadLocal对象，然后更新value值，退出； if (k == key) { e.value = value; return; } //找到了数组中的一个元素Entry，但是key=null，说明虚引用是可被GC回收的状态，赋值完后，整理内存后退出； if (k == null) { replaceStaleEntry(key, value, i); return; } } //此时tab[i]值为null 可以赋值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) /** 对table数组和元素进行整理操作，超过阈值rehash*/ rehash();} 总结一下上述的关系，当我梦创建一个ThreadLocal对象并调用set方法时，这个对象才会去查找当前线程是否包含ThreadLocalMap对象（变量threadLocals,可以理解为Threadlocal对象到value到映射）,没有则创建。在ThreadLocalMap对象里包含了一个Entry[]数组，在数组上面查找返回值。（底层是利用数组构建hash表，解决冲突使用开放地址法。 nextIndex和prevIndex 接下来，我们再细看一下其中涉及到的方法，首先是移动地址i的方法 1234567private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0);}private static int prevIndex(int i, int len) { return ((i - 1 &gt;= 0) ? i - 1 : len - 1);} 分析代码可得，当i超过len时，会访问下标0,也就是说这是循环查找（开饭地址法嘛）。 replaceStaleEntry 当这个已存在的Entry元素key==null的时候，逻辑上就走到——replaceStaleEntry(key, value, i)，该方法是用来替换“陈旧的”Entry的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; /** * 从过期key的位置用preIndex向前查找 * 并标记在staleSlot前连续的Entry中第一个过期的key为stolToExpunge */ for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 从过期key的位置用newIndex向后查找 */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { /** * 从staleSlot后的位置找到一个与key值相同的Entry * 根据开放地址法可知，我们应该清除掉后面的(key,.),把新值到前面的key中 */ e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // 若相等，说明在staleSlot前面找不到失效的key,直接清理i处的slot，退出即可 if (slotToExpunge == staleSlot) slotToExpunge = i; //这里优先清理掉是staleSlot前的过期key cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } /** * 从staleSlot后的位置找到一个与key过期的Entry 且在staleSlot前没有找到一个过期key,才会赋值slotToExpunge 为 i * 到这我们可以发现若要slotToExpunge = i,必须有slotToExpunge == staleSlot * 从这里可以看出优先清理staleSlot位置前过期的key */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; } // 上面循环结束说明后面没有相同的key值需要清理，可直接在staleSlot上赋值 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) //此时说明找到了一个待清除掉slotToExpunge位置，且优先清理靠前的位置。 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);} 在分析上述代码后，我们可知replaceStaleEntry总共做了两件事情： 在过期的key的位置附上新值，（但是在赋值前一定会向后检测是否存在相同key的值，若有一定要清楚掉） 去找在staleSlot里连续的Entry里第一个过期的Endtry的位置，并把它传入expungeStaleEntry（注意这个位置肯定是我们填完新（key,value）后的位置）。 这里给出一张replaceStaleEntry等图示，注意理解连续的Entry的概念 这里有个问题，为啥一定要找连续的Entry里第一个过期的Endtry的位置，我们可以看看expungeStaleEntry方法和cleanSomeSlots方法 expungeStaleEntry 1234567891011121314151617181920212223242526272829303132333435363738private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; /** 清除staleSlot槽位对应的对象引用 */ tab[staleSlot].value = null; tab[staleSlot] = null; size--; /** 数组中元素总数减1 */ Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); /** 如果key==null，则清除掉对应槽位的元素，并且size减1 */ if (k == null) { e.value = null; tab[i] = null; size--; } else { /** * 这里主要的作用是由于采用了开放地址法，所以删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，可以简单理解 * 就是让后面的元素往前面移动。 */ int h = k.threadLocalHashCode &amp; (len - 1); // 应该坐：h 但是我坐在了：i if (h != i) { // 表示k现在所在的位置i并不是它应该在的位置h上。而是由于开放地址法，放到了别的位置上 tab[i] = null; //找到h所在的位置，若tab[h] == null,说明h在前面被清除的位置，直接存值 while (tab[h] != null) { // 说明hash是有冲突的，那么往后找空的位置 h = nextIndex(h, len); } tab[h] = e; } } } //此时在staleSlot和i之间已经没有过期的key,i后面的都是null return i;} 现在我们可以理解为什么要去找最连续entry里第一个过期key了： 根据开放地址法，当我们扫到null时会停止扫描，而当我们扫到过期key时会清理掉该key，为了防止后面的key扫描不到，因此我们应该整理从连续entry里第一个过期key开始整理，遇到一个过期key便删除，同时重新计算后面的每个元素并排序。 cleanSomeSlots 1234567891011121314151617// 初始状态n=lengthprivate boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) { //遇到过期键则删除 n = len; removed = true; i = expungeStaleEntry(i); // 从位置i开始清除Stale元素，并在这个过程中&quot;整理&quot;元素到趋近正确的位置，直到遍历到null的Slot } } while ( (n &gt;&gt;&gt;= 1) != 0); /** n&gt;&gt;&gt;=1相当于n=n/2*/ // i 连续移动log2(len)次，若再每遇到过期键则退出 return removed;} 现在知道为什么这个方法称为cleanSomeSlots,该方法只能保证大部分的陈旧键被删除 可以理解为是对于提升插入速度和table数组内“陈旧”Entry整理耗时的一种平衡处理方案 rehash 12345678private void rehash() { expungeStaleEntries(); /** 清除表中的所有陈旧条目 */ // Use lower threshold for doubling to avoid hysteresis（使用较低的加倍阈值以避免滞后） if (size &gt;= threshold - threshold / 4) { resize(); /** 扩容操作 */ }} 超过table的3/4则扩容。 expungeStaleEntries 遍历table数组里的Entry，调用expungeStaleEntry方法，这里就不粘源码了。 resize 1234567891011121314151617181920212223242526272829303132private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; /** 将原数组大小扩容2倍 */ int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; // Help the GC } else { /**计算旧的Entry在新的table数组中的位置h */ int h = k.threadLocalHashCode &amp; (newLen - 1); /** * 如果位置h已经被别的Entry占据了，那么就向后查找空位，直到找到为止 */ while (newTab[h] != null) { h = nextIndex(h, newLen); } newTab[h] = e; count++; } } } /** 因为使用了新的数组，所以设置一下新的table数组的阈值 */ setThreshold(newLen); size = count; table = newTab;} 简单来说就是创建新数组，遍历旧数组的每一个值，计算新的hashCode，赋值。 get ThreadLocal中get方法就相对简单很多。我们对照源码进行依次解读 12345678910111213public T get() { Thread t = Thread.currentThread();// 获取当前线程 ThreadLocalMap map = getMap(t);//获取ThreadLocalMap对象 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue();} 这里是相似的业务逻辑，若果存在map，则查找对应的entry并返回结果。 但是如果不存在ThreadLocalMap，setInitialValue会创建一个ThreadLocalMap,并返回一个默认值，默认值为null（这里不具体显示代码了）。 我们看一下ThreadLocalMap类下的getEntry方法： 12345678private Entry getEntry(ThreadLocal&lt;?&gt; key) { int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);} 属于基本的hash数组查找法，但是要注意如果查找的entry为空或者e.get() != key时处理方法： 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) {//根据开放地址查找法，若key!=null向后遍历 ThreadLocal&lt;?&gt; k = e.get(); if (k == key)//查找到相同元素就返回 return e; if (k == null)//key为null说明这是一个过期的key expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null;//若e==null则直接返回null} 内存溢出 通过上面的分析，我们知道 expungeStaleEntry() 方法是帮助垃圾回收的。 get 和set 方法都可能触发清理方法 expungeStaleEntry() 正常情况下，不会存在溢出，但是 如果我们没有调用get和set的时候就会可能面临着内存溢出。养成好习惯不再使用的时候调用remove()，加快垃圾回收，避免内存溢出。退一步说，就算我们没有调用get和set和remove方法，线程结束的时候，也就没有强引用再指向ThreadLocal中的ThreadLocalMap了，这样ThreadLocalMap和里面的元素也会被回收掉。但是有一种危险是，如果线程是线程池的，在线程执行完代码的时候并没有结束，只是归还给线程池，这个时候ThreadLocalMap和里面的元素是不会回收掉的。 最近把java并发编程的知识重新整理了一下，有一部分文档写在飞书上了。内容和图片来自于互联网，有侵删。 这是以前做的一些笔记：Java并发编程","link":"2024/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"YHJ23","text":"今天读一篇发在FOCS上的论文 Attribute-Based Encryption for Circuits of Unbounded Depth from Lattices 文章很长，先从方法论下手，浅读一下方法，细节部分日后再补充。 研究背景 目前主流的基于格的ABE芳芳如GVW13,BGG+14等，所能够容纳的电路深度都是有限的，同时它们的组件（主公钥，主私钥，和密文）在最大电路中具有多项式大小深度。（这句话读起来有些费解，我的理解是，例如深度为2，则有22=42^2=422=4个辅助电路加密的公钥或者说对应的密文，而计算密钥时计算深度也会达到2）。为了消除基于格的ABE对电路深度的依赖，作者提出了一种新的方案 研究成果 作者提出构造一个1-key ABE所用到的密码学原语有 laconic function evaluation (LFE) 1-key functional encryption (FE) reusable garbling schemes. 作者构造了一系列上述原语的方案，同时还基于evasive circular LWE assumption（一种加强的evasive LWE assumption）实现了一个比较成熟的ABE方案。 预备知识 再了解整个方案之前，我们先看一下所用到的组件 Circular Evasive LWE 我们先从evasive LWE开始，如下为evasive LWE假设的内容，为了方便理解后面的Circular Evasive LWE,B,A‾′B,\\overline{A}^{\\prime}B,A′采用了相同的分布，两个变量在这里是一样的。 if (1): B,A‾′,P,r⊤B⏟,r⊤⏟A‾′,r⊤P⏟\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{B}}, \\underbrace{\\mathbf{r}^{\\top}} \\overline{\\mathbf{A}}^{\\prime}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{P}}B,A′,P,r⊤B​,r⊤​A′,r⊤P​, aux ≈\\approx≈ (2): B,A‾′,P,$,$,$\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\$B,A′,P,$,$,$, aux, then (3): B,A‾′,P,r⊤B,r⊤A‾′,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\mathbf{r}^{\\top} \\mathbf{B}, \\mathbf{r}^{\\top} \\overline{\\mathbf{A}}^{\\prime}, \\quad \\mathbf{K}B,A′,P,r⊤B,r⊤A′,K, aux ≈\\approx≈ (4): B,A‾′,P,$,$,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\mathbf{K}B,A′,P,$,$,K, aux. 其中B←$Zqn×m\\mathbf{B}\\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_q^{n \\times m}B←$Zqn×m​, m=Θ(nlog⁡p)m=\\Theta(n \\log p)m=Θ(nlogp), K←$B−1(P)\\mathbf{K} \\stackrel{\\$}{\\leftarrow} \\mathbf{B}^{-1}(\\mathbf{P})K←$B−1(P), K\\mathbf{K}K是一个低范数矩阵满足BK=P\\mathbf{B K}=\\mathbf{P}BK=P。我们可以这么去理解这个假设，只要不给敌手获悉BK=P\\mathbf{B K}=\\mathbf{P}BK=P，给定X\\mathbf{X}X,r⊤B+e\\mathbf{r}^{\\top} \\mathbf{B}+er⊤B+e,r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e,不论X\\mathbf{X}X为何种分布，r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e均为伪随机性的。 circular evasive LWE假设如下， if (1), Afhe ,S,Acirc ,s⊤(Acirc −S⊗G)≈(2),$,$,Acirc ,$, then (3), Afhe ,S,Acirr ,s⊤(Acirc −S⊗G)≈ (4), $,$,Acirc , \\begin{aligned} &amp;\\text { if (1), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {circ }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx(2), \\$, \\$, \\mathbf{A}_{\\text {circ }}, \\quad \\$ \\text {, } \\\\ &amp; \\text { then (3), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {cirr }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx \\text { (4), } \\$, \\$, \\mathbf{A}_{\\text {circ }} \\text {, } \\\\ \\end{aligned} ​ if (1), Afhe ​,S,Acirc ​,s⊤(Acirc ​−S⊗G)≈(2),$,$,Acirc ​,$, then (3), Afhe ​,S,Acirr ​,s⊤(Acirc ​−S⊗G)≈ (4), $,$,Acirc ​, ​ 这里暂时认为这个假设是对的，不看这方面的证明。 模数法缩小噪声 我们有如下方法缩减噪声，令MMM为qqq的因子，CCC为一个低深度的电路，如下等式成立： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌋=(s⊤AC, small −C(x)s⊤Gsmall +esmall ⊤) mod qM\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rfloor \\\\ = &amp; \\left(\\mathbf{s}^{\\top} \\mathbf{A}_{C, \\text { small }}-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}+\\mathbf{e}_{\\text {small }}^{\\top}\\right) \\bmod \\frac{q}{M} \\end{aligned}=​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎥⎥⎥​(s⊤AC, small ​−C(x)s⊤Gsmall ​+esmall ⊤​)modMq​​ 经推理可得： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM]=(⌊(s⊤AC+elarge ⊤) mod qM⌉−C(x)s⊤Gsmall ) mod qM=Φ(⌊s⊤AC mod qM⌉−C(x)s⊤Gsmall ) mod qM.\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right] \\\\ = &amp; \\left(\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top} \\mathbf{A}_C+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} \\\\ \\stackrel{\\Phi}{=} &amp; \\left(\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} .\\end{aligned}==Φ​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎤​⎝⎛​⎣⎢⎢⎢​M(s⊤AC​+elarge ⊤​)modq​⎥⎥⎥⎤​−C(x)s⊤Gsmall ​⎠⎞​modMq​(⌊Ms⊤AC​modq​⌉−C(x)s⊤Gsmall ​)modMq​.​ 为了让第一个等式成立，M为2的指数次放，这样可以使得M/GM/GM/G为整数,让M/GM/GM/G能被规约为GsmallG_{small}Gsmall​。 注意第二个等式是概率成立的，即，当elargee_{large}elarge​没有足够大时，可以使得四舍五入后的值相同。通过规约后再乘以M,可以舍得原式变回模M. M⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌉=(M⌊s⊤AC mod qM⌉−C(x)s⊤⋅MGsmall ) mod q\\begin{aligned} &amp; M\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil \\\\ = &amp; \\left(M\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\cdot M \\mathbf{G}_{\\text {small }}\\right) \\bmod q\\end{aligned}=​M⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎥⎥⎥⎤​(M⌊Ms⊤AC​modq​⌉−C(x)s⊤⋅MGsmall ​)modq​ 利用四舍五入可以使得恢复该数恢复到模q。但是这里有个坑，MGsmallMG_{small}MGsmall​只包含较大的2的幂次方，所以还需要设计一种可以恢复G的方法。（这里细节比较多，暂时不讲）解决的大致思路就是把G分为两部分，一部分是可以通过⌊XM⌉M\\left \\lfloor \\frac{X}{M} \\right \\rceil M⌊MX​⌉M复原的部分，和不能通过其复原的部分。 最后我们可以得到函数RemoveNoise(u⊤u^{\\top}u⊤),计算公式如下： vL⊤←u⊤G−1(MGL),vR⊤←u⊤G−1(GR),w⊤←(⌊vL⊤ mod qM⌉,M⌊vR⊤ mod qM⌉)Q,\\begin{array}{l} \\mathbf{v}_{\\mathrm{L}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(M \\mathbf{G}_{\\mathrm{L}}\\right), \\quad \\mathbf{v}_{\\mathrm{R}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{G}_{\\mathrm{R}}\\right), \\\\ \\mathbf{w}^{\\top} \\leftarrow\\left(\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{L}}^{\\top} \\bmod q}{M}\\right\\rceil, M\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{R}}^{\\top} \\bmod q}{M}\\right\\rceil\\right) \\mathbf{Q}, \\end{array} vL⊤​←u⊤G−1(MGL​),vR⊤​←u⊤G−1(GR​),w⊤←(⌊MvL⊤​modq​⌉,M⌊MvR⊤​modq​⌉)Q,​ 这里的Q是什么暂且不深入讲解。 我们定义一个函数RndPad满足： RndPadA(s)=RemoveNoise(s⊤A+e)=s⊤ARndPad_{A}(s)=RemoveNoise(s^{\\top}A+e)=s^{\\top}ARndPadA​(s)=RemoveNoise(s⊤A+e)=s⊤A bootstrapping 接下来是文章中最重要的阶段，我们定义一个 S=(A‾fhe r⊤A‾fhe +efhe ⊤)(R1,…,R(n+1)⌈log⁡2q⌉)−bits⁡(s)⊗G∈Zq(n+1)×m(n+1)⌈log⁡2q⌉ \\begin{array}{l} \\mathbf{S}=\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}}\\left(\\mathbf{R}_{1}, \\ldots, \\mathbf{R}_{(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}\\right) \\\\ -\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G} \\in \\mathbb{Z}_{q}^{(n+1) \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil} \\end{array} S=(r⊤Afhe ​+efhe ⊤​Afhe ​​)(R1​,…,R(n+1)⌈log2​q⌉​)−bits(s)⊗G∈Zq(n+1)×m(n+1)⌈log2​q⌉​​ A‾fhe ,R\\overline{\\mathbf{A}}_{\\text {fhe }},RAfhe ​,R均可以理解为随机矩阵。 我们定义循环编码为： s⊤(Acirc −(1,bit(S))⊗G)+ecirc \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1,\\text{bit}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{circ}} s⊤(Acirc ​−(1,bit(S))⊗G)+ecirc​ 则对于该循环编码，存在 EvalRndPad(Acirc ,A)=HARdPad EvalRndPadS(Acirc ,A,S)=HA,SRdPad \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}) = \\mathbf{H}_{\\mathbf{A}}^{\\text {RdPad }}\\\\ \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} EvalRndPad(Acirc ​,A)=HARdPad ​EvalRndPadS(Acirc ​,A,S)=HA,SRdPad ​ 满足： s⊤(Acirc −(1,bits⁡(S))⊗G)HA,SRdPad =s⊤Acirc HARndPad −RndPad⁡A(s)+efhe ⊤RRndPad A\\begin{aligned} &amp; \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} \\\\ = &amp; \\mathbf{s}^{\\top} \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}}^{\\text {RndPad }}-\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})+\\mathbf{e}_{\\text {fhe }}^{\\top} \\mathbf{R}_{\\text {RndPad }_{\\mathbf{A}}} \\end{aligned} =​s⊤(Acirc ​−(1,bits(S))⊗G)HA,SRdPad ​s⊤Acirc ​HARndPad ​−RndPadA​(s)+efhe ⊤​RRndPad A​​​ 实际上，通过，观察我们可以发现这里将(1,bits⁡(S))(1, \\operatorname{bits}(\\mathbf{S}))(1,bits(S))转化成RndPad⁡A(s)\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})RndPadA​(s),实际上是做了一个RemoveNoise的运算电路， Unbounded Homomorphic Evaluation 这部分运算同EvalC,和EvalCX一样分别分为两部分UEvalC和UEvalX（详见BGG+14）,我们可以这样直观的理解： EvalC/UEvalC: 发声于密钥生成阶段，电路C可以是任意的，属于一种明文态的同态计算。 EvalCX/UEvalCX: 发声于解密阶段，若想要正确解密，电路C必须满足C(x)=1C(x)=1C(x)=1，属于一种密文态的同态计算。 我们来看在论文中的描述： UEvalC UEvalC(Aattr ,Acirc ,C)\\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)UEvalC(Aattr ​,Acirc ​,C) takes as input Aattr ∈Zq(n+1)×(L+1)m,Acirc ∈Zq(n+1)×(LS+1)m\\mathbf{A}_{\\text {attr }} \\in \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\quad \\mathbf{A}_{\\text {circ }} \\in \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m} Aattr ​∈Zq(n+1)×(L+1)m​,Acirc ​∈Zq(n+1)×(LS​+1)m​ and a circuit C:{0,1}L→{0,1}1×L′C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}^{1 \\times L^{\\prime}}C:{0,1}L→{0,1}1×L′ of arbitrary size and depth, where LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^{2}\\left\\lceil\\log _{2} q\\right\\rceil^{2}LS​=m(n+1)2⌈log2​q⌉2. 这里给出了UEvalC的基本算法，注意一下不论是Aattr\\mathbf{A}_{\\text {attr}}Aattr​还是Acirc\\mathbf{A}_{\\text {circ}}Acirc​都是用于构造电路的算法的。先令Aattr=(A0,A1,…,AL)\\mathbf{A}_{\\text {attr}}=\\left (\\mathbf{A}_{0},\\mathbf{A}_{1},\\dots,\\mathbf{A}_{L} \\right )Aattr​=(A0​,A1​,…,AL​), 我们可以先用Acirc\\mathbf{A}_{\\text {circ}}Acirc​做传统的电路运算 HCi′←EvalC⁡((A0,Ai′,Ai′′), gate Ci as one-gate circuit ),Ai′←(A0,Ai′,Ai′′)HCi′\\begin{array}{l} \\mathbf{H}_{C_{i}}^{\\prime} \\leftarrow \\operatorname{EvalC}\\binom{\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right),}{\\text { gate } C_{i} \\text { as one-gate circuit }}, \\\\ \\mathbf{A}_{i}^{\\prime} \\leftarrow\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right) \\mathbf{H}_{C_{i}}^{\\prime} \\\\ \\end{array} HCi​′​←EvalC( gate Ci​ as one-gate circuit (A0​,Ai′​,Ai′′​),​),Ai′​←(A0​,Ai′​,Ai′′​)HCi​′​​ 最后根据上面的运算结果，即： HAi′RndPad←EvalRndPad(Acirc ,Ai′),Ai←Acirc HAi′RndPad\\begin{array}{l} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}} \\leftarrow \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{i}^{\\prime}), \\\\ \\mathbf{A}_{i} \\leftarrow \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}}\\\\ \\end{array} HAi′​RndPad​←EvalRndPad(Acirc ​,Ai′​),Ai​←Acirc ​HAi′​RndPad​​ 这里摘自于原论文，个人感觉符号使用有点混乱了 UEvalCX 这里就是同理了，不再过多赘述，如果在密态情况下EvalCX,计算出来的是形如： AwithLargeNoise′=s⊤(AC−C(x)⊗G)+elarge \\mathbf{A}_{\\text{withLargeNoise}}^{\\prime}=\\mathbf{s}^{\\top}\\left(\\mathbf{A}_{C}-C(x) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{large}} AwithLargeNoise′​=s⊤(AC​−C(x)⊗G)+elarge​ 但是在计算 EvalRndPadS(Acirc ,AwithLargeNoise′,S)=HA,SRdPad \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{\\text{withLargeNoise}}^{\\prime},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }}EvalRndPadS(Acirc ​,AwithLargeNoise′​,S)=HA,SRdPad ​ 中，由于用了循环编码EvalRndPadS可以计算出与EvalRndPad相同的值。 方案 先来看看方案的原算法吧，为了更好的理解以下摘自于原文，我会附上相关的自己的理解 Setup (1L)\\left(1^L\\right)(1L) defines appropriate n,m,q,σ,σ′,σ−1n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1}n,m,q,σ,σ′,σ−1​, σpost \\sigma_{\\text {post }}σpost ​ as described at the end of Section 3, and sets LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^2\\left\\lceil\\log _2 q\\right\\rceil^2LS​=m(n+1)2⌈log2​q⌉2. The algorithm samples: Aattr ←Zq(n+1)×(L+1)m,Acirc ←Zq(n+1)×(LS+1)m,(B,τ)←TrapGen⁡(1n,1m,q),z←Zqn\\begin{aligned} \\mathbf{A}_{\\text {attr }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\\\ \\mathbf{A}_{\\text {circ }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m}, \\\\ (\\mathbf{B}, \\tau) &amp; \\leftarrow \\operatorname{TrapGen}\\left(1^{n}, 1^{m}, q\\right), \\quad \\mathbf{z} \\leftarrow \\mathbb{Z}_{q}^{n} \\end{aligned} Aattr ​Acirc ​(B,τ)​←Zq(n+1)×(L+1)m​,←Zq(n+1)×(LS​+1)m​,←TrapGen(1n,1m,q),z←Zqn​​ It outputs mpk=(n,m,q,σ,σ′,σ−1,σpost ,Aatt ,Acirc ,B,z),msk=(mpkτ)\\mathrm{mpk}=\\binom{n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1},}{\\sigma_{\\text {post }}, \\mathbf{A}_{\\text {att }}, \\mathbf{A}_{\\text {circ }}, \\mathbf{B}, \\mathbf{z}}, \\mathrm{msk}=\\binom{\\mathrm{mpk}}{\\tau}mpk=(σpost ​,Aatt ​,Acirc ​,B,zn,m,q,σ,σ′,σ−1​,​),msk=(τmpk​). 启动阶段，生成陷门和循环电路参数以及属性参数。 KeyGen(msk,C)(msk, C)(msk,C) takes msk,C:{0,1}L→{0,1}msk, C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}msk,C:{0,1}L→{0,1} as input. It computes AC←UEvalC(Aattr ,Acirc ,C)\\mathbf{A}_{C} \\leftarrow \\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)AC​←UEvalC(Aattr ​,Acirc ​,C) and samples z′←Zqn+1\\mathbf{z}^{\\prime} \\leftarrow \\mathbb{Z}_{q}^{n+1}z′←Zqn+1​. The algorithm generates a trapdoor k←$SimplD(B,τ,A‾CG−1(z′)+z,σ−1),k \\stackrel{\\$}{\\leftarrow} \\text{SimplD}(\\mathbf{B},\\tau,\\overline{\\mathbf{A}}_{C}G^{-1}(z')+z,\\sigma_{-1}), k←$SimplD(B,τ,AC​G−1(z′)+z,σ−1​), whereA‾C∈Zqn×m\\overline{\\mathbf{A}}_{C} \\in \\mathbb{Z}_{q}^{n \\times m}AC​∈Zqn×m​ is the the first nnn rows of AC\\mathbf{A}_{C}AC​. The algorithm outputs skC=(z′,k)\\mathrm{sk}_{C}=\\left(\\mathbf{z}^{\\prime}, \\mathbf{k}\\right)skC​=(z′,k). 这里做了UEvalC计算，并且运用了陷门，生成密钥，若想要解密，必须生成相同的值 可以理解为用陷门对ACA_{C}AC​进行了一次签名，只不过这种签名是密态的。 Enc (mpk,x,μ)(\\mathrm{mpk}, \\mathbf{x}, \\mu)(mpk,x,μ) takes mpk,x∈{0,1}L,μ∈{0,1}mpk, \\mathbf{x} \\in\\{0,1\\}^{L}, \\mu \\in\\{0,1\\}mpk,x∈{0,1}L,μ∈{0,1} as input. It samples r←DZ,σ,≤σλn\\mathbf{r} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{n}r←DZ,σ,≤σλ​n​ and sets s←(r⊤,−1)⊤\\mathbf{s} \\leftarrow\\left(\\mathbf{r}^{\\top},-1\\right)^{\\top}s←(r⊤,−1)⊤. The algorithm creates a circular encryption by A‾fhe ←&amp;Zqn×m,efhe ←&amp;DZ,σ,≤σλmR←${0,1}m×m(n+1)⌈log⁡2q⌉,Afhe ←(A‾fhe r⊤A‾fhe +efhe ⊤), S←Afhe R−bits⁡(s)⊗G,\\begin{array}{l} \\overline{\\mathbf{A}}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_{q}^{n \\times m}, \\quad \\mathbf{e}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{m}\\\\ \\mathbf{R} \\stackrel{\\$}{\\leftarrow}\\{0,1\\}^{m \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}, \\\\ \\mathbf{A}_{\\text {fhe }} \\leftarrow\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}} \\text {, } \\\\ \\mathbf{S} \\leftarrow \\mathbf{A}_{\\text {fhe }} \\mathbf{R}-\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G}, \\\\ \\end{array} Afhe ​←&amp;Zqn×m​,efhe ​←&amp;DZ,σ,≤σλ​m​R←${0,1}m×m(n+1)⌈log2​q⌉,Afhe ​←(r⊤Afhe ​+efhe ⊤​Afhe ​​), S←Afhe ​R−bits(s)⊗G,​ than encoding by eattr ←DZ,σ′,≤σ′λ(L+1)m,ecirc ←DZ,σ′,≤σ′λ(Ls+1)m,cattr ⊤←s⊤(Aattr −(1,x⊤)⊗G)+eattr ⊤,ccirc ⊤←s⊤(Acirc −(1,bits⁡(S))⊗G)+ecirc ⊤.\\begin{array}{l} \\mathbf{e}_{\\text {attr }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L+1) m}, \\quad \\mathbf{e}_{\\text {circ }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L \\mathbf{s}+1)m}, \\\\ \\mathbf{c}_{\\text {attr }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {attr }}-\\left(1, \\mathbf{x}^{\\top}\\right) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {attr }}^{\\top}, \\\\ \\mathbf{c}_{\\text {circ }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {circ }}^{\\top} . \\end{array} eattr ​←DZ,σ′,≤σ′λ​(L+1)m​,ecirc ​←DZ,σ′,≤σ′λ​(Ls+1)m​,cattr ⊤​←s⊤(Aattr ​−(1,x⊤)⊗G)+eattr ⊤​,ccirc ⊤​←s⊤(Acirc ​−(1,bits(S))⊗G)+ecirc ⊤​.​ It also generates the message encoding as eB←DZ,σpost ,≤σpost λm,emsg←DZ,σ′,≤σ′λcB⊤←r⊤B+eB⊤,cmsg←r⊤z+emsg+μ⋅⌊q/2⌉.\\begin{aligned} \\mathbf{e}_{\\mathrm{B}} &amp; \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma_{\\text {post }}, \\leq \\sigma_{\\text {post }} \\sqrt{\\lambda}}^{m}, \\quad e_{\\mathrm{msg}} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}} \\\\ \\mathbf{c}_{\\mathrm{B}}^{\\top} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{B}+\\mathbf{e}_{\\mathrm{B}}^{\\top}, \\\\ c_{\\mathrm{msg}} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{z}+e_{\\mathrm{msg}}+\\mu \\cdot\\lfloor q / 2\\rceil . \\end{aligned} eB​cB⊤​cmsg​​←DZ,σpost ​,≤σpost ​λ​m​,emsg​←DZ,σ′,≤σ′λ​​←r⊤B+eB⊤​,←r⊤z+emsg​+μ⋅⌊q/2⌉.​ The algorithm outputs ctx=(S,cattr,ccirc,cB,cmsg)ctx = (S, c_{attr}, c_{circ}, c_{B}, c_{msg})ctx=(S,cattr​,ccirc​,cB​,cmsg​). 与BGG+14不同的是生成了一个循环编码的密文。 Dec (A‾Ca‾C⊤)=AC←UEvalC⁡(Aatr ,Acirc ,C),cC,x⊤←UEvalCX⁡(Aattr ,cattr ⊤,Acirc ccirc ⊤,C,x,S),c′←cmsg+cC,x⊤G−1(z′)−(cB⊤k−a‾C⊤G−1(z′)).\\begin{aligned} \\binom{\\overline{\\mathbf{A}}_{C}}{\\underline{\\mathbf{a}}_{C}^{\\top}} &amp; =\\mathbf{A}_{C} \\leftarrow \\operatorname{UEvalC}\\left(\\mathbf{A}_{\\text {atr }}, \\mathbf{A}_{\\text {circ }}, C\\right), \\\\ \\mathbf{c}_{C, \\mathbf{x}}^{\\top} &amp; \\leftarrow \\operatorname{UEvalCX}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{c}_{\\text {attr }}^{\\top}, \\mathbf{A}_{\\text {circ }} \\mathbf{c}_{\\text {circ }}^{\\top}, C, \\mathbf{x}, \\mathbf{S}\\right), \\\\ c^{\\prime} &amp; \\leftarrow c_{\\mathrm{msg}}+\\mathbf{c}_{C, \\mathbf{x}}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)-\\left(\\mathbf{c}_{\\mathrm{B}}^{\\top} \\mathbf{k}-\\underline{\\mathbf{a}}_{C}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)\\right) . \\end{aligned} (a​C⊤​AC​​)cC,x⊤​c′​=AC​←UEvalC(Aatr ​,Acirc ​,C),←UEvalCX(Aattr ​,cattr ⊤​,Acirc ​ccirc ⊤​,C,x,S),←cmsg​+cC,x⊤​G−1(z′)−(cB⊤​k−a​C⊤​G−1(z′)).​ 最后我们对上文所有组件的分析，由与在密态下计算一个UEvalCX可以消除掉在属性电路CCC生成的噪声，因此最后的噪声与CCC无关，仅与removeNoise电路编码的生成的噪声有关，但是removeNoise是一个固定值，所以实现了一个电路无界的功能。","link":"2024/05/28/YHJ23/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"2024/05/27/hello-world/"},{"title":"hexo-Icarus页面优化","text":"记录一次页面调整，简单介绍一下，本人前端小白，style语法基本不懂，关于页面大小问题查询了很多资料。最后调整将大小调整到一个比较满意的程度 页面宽度调整 众所周之hexo初始设置中，内容展示页面过小，两边距离过大，因此文章内容看起来及其不自然。 经过我查阅以下及相关文档： Icarus主题美化 Icarus widget 宽度如何修改？ Hexo博客icarus主题定制篇 Hexo博客主题之Icarus的设置与美化 风月的博客（非常全） 等内容总算是明白怎样设置了【痛哭】 有不少大佬改成首页内容为三栏，文章浏览为两栏的模式，但本文仅针对两栏的改写。 调整文章内容页面宽度 步骤一 修改themes/icarus/include/style/base.styl文件为： 123\\\\第26行- $gap ?= 32px+ $gap ?= 32px 这段代码可以减小两边的空白 步骤二 修改themes/icarus/layout/layout.jsx文件为 123\\\\第29行- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 注意是把第三个8改成9，这段代码代表当采用两栏格式时，会扩大文章内容页面，但是修改过后左右两边会不对称，也就是github上讨论的问题 步骤三 修改themes/icarus/layout/common/widgets.jsx文件为 1234case 2:\\\\第44行- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; 这段代码代表当文章为两栏时，使得widget宽度为3，注意必须使得文章内容长度+widget宽度为12，否则格式会乱 标题调整 我在themes/icarus/include/style/article.styl文件中设置了标题的大小和颜色，具体看风月的博客。 雪花效果 雪花效果 试了试，好像没啥效果，以后再总结 高级用途 强推：hexo写文在必备","link":"2024/06/15/hexo-Icarus%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"},{"title":"常见漏洞原理","text":"在这篇文章中我会收录一些常见的漏洞及其原理，同时分析抵御该漏洞的相关方法，即能够加强在做研发过程中的安全意识，也能为结合后面学习spring security打下基础。 SQL注入 简介 在输⼊的字符串中注⼊SQL指令，这些注⼊的恶意指令会被数据库服务器误认为是正常的SQL指令⽽允许，系统因此遭到破坏或是⼊侵。 SQL注入主要分为以下几类： • 基于布尔类型的盲注，即可以根据返回⻚⾯判断条件真假的注⼊。 • 基于时间的盲注，即不能根据⻚⾯返回的内容判断任何信息，要⽤条 件语句查看时间延迟语句是否⼰执⾏（即⻚⾯返回时间是否增加）来判 断。 • 基于报错注⼊，即⻚⾯会返回错误信息，或者把注⼊的语句的结果直 接返回到⻚⾯中。 • 联合查询注⼊，在可以使⽤Union 的情况下的注⼊。 • 堆查询注⼊，可以同时执⾏多条语句时的注⼊。 基于布尔类型的盲注 适⽤场景：后端执行sql执⾏的结果不会直接显示在前端，但是会在前端显示正确或者错误。 布尔注入的的原理： 获取数据库名字的⻓度： select length(DATABASE())。 截取字符, 使用 123select MID('string',2,2);select substr('string',2);select left('string',2); 其中substr 和 MID作⽤⼀样，left是从字符串左边截取字符. 3. 为了⽅便遍历，⽤到for循环，适⽤ASCII：ASCII 和 ARD作⽤⼀样 通过以上方法进行枚举，先猜⻓度，再猜每⼀位上的字符，获取库名，表名，列名，数据（字段值）。 也可以使⽤⼆分法去暴⼒枚举，这样更快，例如：⻓度&gt;=8是否成⽴ 基于时间的盲注 适⽤场景：既没有数据回显，也不会在sql语句正确与否时显示不同的内容。(即前端不会显示任何信息) 基于时间的盲注原理：利用判断条件和sql中的sleep方式判断条件是否正确。（可以理解为在数据库端端一种布尔注入，原本前端没有任何显示信息，可以通过反应时间了解正确或错误） 如利用： 123select sleep(if(select length(database())=8),1,0);select if(length(database())=8,sleep(1),0);-- 两者等价 基于报错的注⼊ 这个比较好理解，前端会把后台报错的信息打印出来. extractValue()是一个 XML 处理函数，它从给定的 XML 片段中提取值。通过构造一个不正确的 XML 片段，可以触发一个错误消息，其中包含我们插入的恶意数据。 updatexml() 是一个 XML 更新函数，用于更新给定 XML 片段中的节点。通过构造一个不正确的 XML 更新语句，同样可以触发一个错误消息。 实例如下： 12select extractValue('',concat('-',database()));select updatexml('',concat('-',database()),''); 会分别产生如下报错信息 对于 extractValue()： 1SQL Error (1105): XPATH syntax error: '-'database_name 对于 updatexml()： 1SQL Error (1105): XPATH syntax error: '-'database_name SQL注入的基本流程 判断是否有sql注⼊漏洞,方法如下： 加⼀个单引号’，看是否出错，因为引号必须成对出现，否则会出错（判断是否能注入）。 两次尝试 1=1 正常输出，1=2错误输出，证明SQL语句⽣效，存在SQL注⼊漏洞（判断是否能布尔注入）。 1select first_name,last_name from user where user_id='1'and 1=#'; 获得数据库名,可利用union等类似的联合查询 获得表名 获取列名 获得数据 获取对应元数据的方法依然是采用遍历查找的办法。 防御方法 根源问题：服务端把⽤户输⼊当作命令执⾏ 校验⽤户输⼊参数，过滤连接符 对用户输入转义 数据库异常信息隐藏，将异常进⾏封装，防⽌基于报错的SQL注⼊ 数据库敏感信息加密，⽤MD5哈希的时候，记得加盐 安装web应⽤防⽕墙WAF 将输⼊进⾏参数化 命令注入漏洞 和sql注入类似，将用户对输入当成shell命令去执行。这里不赘述了 文件上传漏洞 简介 前端⻚⾯需要⽤户上传⽂件的时候，攻击者上传恶意的⽂件，⽐如上传后⻔病毒⽊⻢到⽹站中，⽹站因此遭到破坏或是⼊侵。 防御方法 这里给几个简单的防御手段。 代码层面： 在前后端增加文件校验接口 对文件进行内容二次渲染 重命名文件，将文件隔离出来，访问时只访问文件的路径。 管理层面： 部署WAF防⽕墙 正确配置服务器请求类型(禁⽌使⽤PUT请求⽅法) 及时更新系统、中间件、脚本、数据库、CMS或框架的漏洞补丁(避免解析漏洞) 权限控制层面： 限制上传⽬录下拥有的执⾏权限 XSS跨站脚本攻击 原理：跨站脚本攻击利⽤了⽹站对⽤户输⼊的不正确处理，使得恶意⽤户能够向受害者的⽹⻚中注⼊恶意脚本。这些脚本在⽤户浏览器中执⾏，从⽽ 导致安全⻛险。跨站脚本攻击的主要原理包括： ⽤户输⼊未经过滤或转义：⽹站未正确过滤或转义⽤户输⼊，使得恶意⽤户能够插⼊恶意脚本。 脚本在⽤户浏览器中执⾏：⼀旦恶意脚本被注⼊到受害者的⽹⻚中，它将在⽤户浏览器中执⾏，攻击者可利⽤此执⾏环境进⾏进⼀步攻击。 常见的事发网站：日志，小说，论坛等内容存储网站。 XSS攻击类别 反射型 XSS 反射型 XSS 是最常⻅的 XSS 攻击类型。攻击者构造恶意的 URL，其中包含恶意脚本。当⽤户点击带有恶意参数的 URL 时，服务器将恶意脚本作 为响应的⼀部分返回给⽤户浏览器，并在浏览器中执⾏。 存储型 XSS 存储型 XSS 发⽣在⽹站存储⽤户提交的数据，且未经过滤或转义的情况下直接在⽹⻚中显示。攻击者提交包含恶意脚本的数据，然后其他⽤户在访问包含该数据的⻚⾯时，恶意脚本将在他们的浏览器中执⾏。 DOM型 XSS DOM 型 XSS 是基于⽂档对象模型（Document Object Model，DOM）的⼀种XSS攻击。攻击者构造恶意URL，其中包含恶意脚本。当⽤户点击包含恶意参数的URL时，恶意脚本修改⻚⾯的 DOM 结构，从⽽导致安全漏洞。 利用流程 总体通过四种途径来利用： 输入字段和表单 URL参数 富文本编辑器 防御方法 为了有效防御跨站脚本攻击，以下是⼀些常⻅的防御措施： 输⼊验证和过滤 ⽹站应该对⽤户输⼊的数据进⾏验证和过滤，确保只接受预期的输⼊。例如，可以使⽤⽩名单过滤，只允许特定字符和标记，同时拒绝其他 潜在的恶意脚本。 输出转义 在将⽤户输⼊的数据显示在⽹⻚中时，应该对其进⾏适当的输出转 义，以确保浏览器将其视为纯⽂本⽽不是可执⾏的代码。这样可以防⽌恶 意脚本在⽤户浏览器中执⾏。 设置 HTTP 头部 通过设置适当的 HTTP 头部，可以增强⽹站的安全性。例如，可以使⽤ Content Security Policy（CSP）来限制⻚⾯中允许执⾏的脚本来源，从⽽减少跨站脚本攻击的⻛险。 CSRF跨站请求伪造 原理:攻击者通过伪造⽤户的浏览器的请求，向访问⼀个⽤户⾃⼰曾经认证访问过的⽹站发送出去，使⽬标⽹站接收并误以为是⽤户的真实操作⽽去执⾏命令。常⽤于盗取账号、转账、发送虚假消息等。攻击者利⽤⽹站对请求的验证漏洞⽽实现这样的攻击⾏为，⽹站能够确认请求来源于⽤户的浏览器，却不能验证请求是否源于⽤户的真实意愿下的操作⾏为。 CSRF等攻击流程 用户浏览并登录信任的网站 A，通过用户认证后，会在浏览器中生成针对 A 网站的 Cookie； 用户在没有退出网站 A 的情况下访问网站 B，然后网站 B 向网站 A 发起一个请求； 用户浏览器根据网站 B 的请求，携带 Cookie 访问网站 A； 由于浏览器会自动带上用户的 Cookie，所以网站 A 接收到请求之后会根据用户具备的权限进行访问控制，这样相当于用户本身在访问网站 A，从而网站 B 就达到了模拟用户访问网站 A 的操作过程。 关于CORS 这里我想要提一嘴cors,经常做研发的小伙伴都知道，跨域问题在我们日常开发中特别常见。 由于当下的 Web 应用程序开发基本都采用了前后端分离的开发模式，例如，当我们访问“test.com”前端域名时，在前端中会访问“api.test.com”后端路由获得服务。但是这个请求已经跨越了两个域名，因此浏览器默认会拒绝这种访问。 请注意，跨域是浏览器的一种同源安全策略，是浏览器单方面限制的，所以仅在客户端运行在浏览器中才需要考虑这个问题。 浏览器在 HTTP 请求的消息头部分新增一些字段，如下所示： 123456//浏览器自己设置的请求域名Origin //浏览器告诉服务器请求需要用到哪些 HTTP 方法Access-Control-Request-Method//浏览器告诉服务器请求需要用到哪些 HTTP 消息头Access-Control-Request-Headers 当浏览器进行跨域请求时会和服务器端进行一次的握手协议，从响应结果中可以获取如下信息: 123456//指定哪些客户端的域名允许访问这个资源Access-Control-Allow-Origin //服务器支持的 HTTP 方法Access-Control-Allow-Methods //需要在正式请求中加入的 HTTP 消息头Access-Control-Allow-Headers 综上所述，浏览器在跨域请求时会和服务器通信访问的方法和访问的源域名。而服务器恰好可以设置允许哪些域名可以访问，那么我们就知道如何解决CORS问题了：服务器合理设置这些响应结果中的消息头。 就是我们开发中经常使用的CorsFilter 123config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));config.setAllowedMethods(Arrays.asList(&quot;*&quot;)); 通过这样的配置使得所有请求可以跨域访问。注意这样配置的重点是让浏览器能够将所有其他域的请求转发给服务器，如果要防止CSRF类的攻击，后端还是要对所有请求做校验。 小结一下：CSRF 是一种攻击行为，所以我们需要对系统进行保护，而 CORS 更多的是一种前后端开发模式上的约定。 防御方法 验证 HTTP Referer 字段:根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，它记录了该 HTTP 请求的来源地址。服务端只需要娇艳请求验证其 Referer 值。 在请求地址中添加 token 并验证:可以在 HTTP 请求中以参数的形式加⼊⼀个随机产⽣的token，并在服务器端建⽴⼀个拦截器来验证这个 token，如果请求中没有token 或者 token 内容不正确，则认为可能是 CSRF 攻击⽽拒绝该请求。 这里补充几个小知识点： 浏览器在Post请求中自动带上cookie的条件（假设请求http://aaa.www.com/xxxxx/list）： 1、domain=域名,或者为其子域名（aaa.www.com 和www.com） 2、仅在 HTTPS 安全通信时才会发送 Cookie 3、path=PATH 注意：每个cookie都存在着domain和path存储cookie来自的域和请求路径。 CSRF token 不会自动被浏览器附带在请求中，需要开发者显式添加。这意味着攻击者不能仅凭 cookie 发起有效请求，因为缺少正确的 token。所以token可以抵御csrf攻击 在 HTTP 头中⾃定义属性并验证: SSRF 服务端请求伪造 SSRF （Server-Side Request Forgery），服务器端请求伪造，是强制服务器发起由攻击者伪造的请求的⼀种安全漏洞。 请求伪造，就是攻击者伪造正常的请求，以达到攻击的⽬的，就是常⻅的Web安全漏洞之⼀。如果“请求伪造”发⽣在服务器端，那么这个漏洞就叫做“服务器端请求伪造”。 漏洞原因 服务端提供了从其他服务器应⽤（也可以是本地）获取数据的功能；服务端对⽤户提供的URL和远端服务器返回的信息没有进⾏合适的验证或者过滤。 漏洞利用流程 当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的。如图 这里我们可以推断出，在服务端提供重定向访问的服务如RedirectView.setURL等，容易存在SSRF漏洞 OK，这篇文章的内容就先到这，后面再补充一些安全相关的知识","link":"2024/06/05/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"},{"title":"git：你的亲爸爸","text":"git作为最常用的分布式版本控制工具，是企业合作开发比不可少的工具。当你发布的代码出现问题后，大多都是靠git来解决的。目前市面上git的使用方法有很多，本文会总结大部分工作中常用的git命令(对于一些少见的复杂场景下的git应用，这个到时候再查也没问题)，总而言之，如果你的代码出了岔子抑或着捅了什么篓子，git绝对是帮你兜底的亲爸爸般的存在。 基本原理 首先聊一下git的基本原理： 如图：git分为四个区域 Workspace： 工作区，就是平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器 我们通常开发工作方式，是从主分支创建一条属于自己的分支，在这个分支上完成自己要实现的功能。再将自己的分支提交给远程仓库实现代码合作。而企业开发中，远程仓库是通常分为多种分支，每个分支对应一种环境，例如 测试环境：所有人员提交的分支都会先合并到这个分支中，在这个分支上自动构建项目，来测试功能是否正常运行，测试环境是给开发人员用，用于调试代码。 预发布环境：预发布环境是给产品人员用的，如果产品觉得没有问题了，就可以准备正式上线到生产环境。 生产环境：到这一步就是给广大的客户使用的。 通常企业会利用工具自动在这些分支上构建项目，程序员要做的就是把自己的分支合并到这些分支上。 一次基本的拉去分支的流程 相信很多同学都用过githubclone代码，这里就不赘述了。通常情况下，我们在企业开发过程中，如果有分配到相关的需求，需要我们自己来在远程创建属于自己的分支（这个过程通常有用相关系统一键式创建，不用自己敲命令）。记得在主分支上执行： 1git pull 拉取最新代码（自己的远程分支），通过 1git checkout [分支名] 来切换到自己的分支并开发最后 12git add # 将文件放入缓存区，我们可以通过 git status 查看是否有未提交的文件git commit -m &quot;hello git&quot; 实现提交，此时用git log查看可以看到字节提交的记录。也许会用同学说，现在使用idea基可以通过图形化工具来解决，跟不需要了解这些命令，作者本人在刚入行的时候也甚是喜欢idea图形化工具，但是idea的图形化工具除了执行git命令外还增加了一些代码审查、提示等其他功能，个人认为如果做为页面展示工具十分不错，但是如果是涉及核心等如merge,reset,cherypick等操作，还是用命令行工具比较方便。 解冲突 马上就来到开发中最常见的情形–发生冲突。冲突一般发生在git merge合并时，当你上传代码到远程并试图合并到测试分支上时，若存在另一个小伙伴，在你改动代码到同一处地方进行修改，且已经合到了测试分支上。由于你们的分支都是从master分支拉取下来的，你们在开发代码时彼此看不到互相的改动，当代码合并时就会发生冲突。 既然知道了冲突是怎么发生的，那么解冲突的位置也就一目了然了。冲突时发生在我们试图将测试分支合并到测试分支上时发生的，那么解决冲突就是在测试分支上解决。 注意","link":"2024/06/29/git%EF%BC%9A%E4%BD%A0%E7%9A%84%E4%BA%B2%E7%88%B8%E7%88%B8/"}],"tags":[{"name":"并发编程","slug":"并发编程","link":"tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"源码解析","slug":"源码解析","link":"tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Lattice","slug":"Lattice","link":"tags/Lattice/"},{"name":"ABE","slug":"ABE","link":"tags/ABE/"},{"name":"hexo","slug":"hexo","link":"tags/hexo/"},{"name":"安全","slug":"安全","link":"tags/%E5%AE%89%E5%85%A8/"},{"name":"工具","slug":"工具","link":"tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"java","slug":"java","link":"categories/java/"},{"name":"基于格的属性基加密","slug":"基于格的属性基加密","link":"categories/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/"},{"name":"网络安全","slug":"网络安全","link":"categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"工作","slug":"工作","link":"categories/%E5%B7%A5%E4%BD%9C/"}],"pages":[]}